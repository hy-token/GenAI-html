<body>
  <h1>Stateパターン</h1>

  <div style="background-color: #e6f7ff; border-left: 5px solid #1890ff; padding: 15px; margin: 20px 0;">
    <h3>問題：</h3>
    <p>オブジェクトの内部状態が変化したときに、そのオブジェクトの振る舞いを変更したい。状態に依存する複雑な条件分岐を避けたい。</p>
    <h3>例えば：</h3>
    <p>自動販売機は、お金が投入されているかどうか、商品が選択されているかどうかなど、状態によって振る舞いが変わる。</p>
  </div>

  <h2>1. Stateパターンとは</h2>
  <p>Stateパターンは、オブジェクトの内部状態が変化したときに、そのオブジェクトの振る舞いが変化するように見えるデザインパターンです。オブジェクトの状態を表す別のオブジェクトを作成し、各状態オブジェクトが特定の状態での振る舞いを実装します。</p>
  
  <p>簡単に言うと、「状態に応じて振る舞いを変える」パターンで、状態をクラスとして表現することで、複雑な条件分岐を避けることができます。</p>

  <h2>2. どんなときに使うの？</h2>
  <p>以下のような場合にStateパターンが役立ちます：</p>
  <ul>
    <li><strong>オブジェクトの振る舞いが内部状態に依存する場合</strong>：状態が変わると動作が変わる</li>
    <li><strong>状態に依存する条件分岐が複雑になっている場合</strong>：ifやswitchの連鎖を避けたい</li>
    <li><strong>状態遷移のルールがコード全体に散らばっている場合</strong>：状態遷移のロジックを集約したい</li>
    <li><strong>新しい状態や振る舞いを追加する可能性がある場合</strong>：既存のコードを変更せずに拡張したい</li>
    <li><strong>コードの保守性と可読性を向上させたい場合</strong>：各状態の責任を明確にしたい</li>
  </ul>

  <h2>3. 仕組み</h2>
  <p>Stateパターンは以下の要素から構成されます：</p>
  <ol>
    <li><strong>Context（コンテキスト）</strong>：現在の状態を保持し、状態オブジェクトへのインターフェースを提供するクラス</li>
    <li><strong>State（状態）</strong>：特定の状態での振る舞いを定義するインターフェースまたは抽象クラス</li>
    <li><strong>ConcreteState（具体的な状態）</strong>：Stateインターフェースを実装し、特定の状態での振る舞いを提供するクラス</li>
  </ol>

  <svg width="100%" height="500" viewBox="0 0 700 500">
    <!-- Context -->
    <rect x="50" y="50" width="200" height="120" rx="10" ry="10" fill="#b3e2cd" stroke="#333" stroke-width="2" />
    <text x="150" y="80" font-family="Arial" font-size="16" text-anchor="middle">Context</text>
    <text x="150" y="105" font-family="Arial" font-size="12" text-anchor="middle">- state: State</text>
    <text x="150" y="125" font-family="Arial" font-size="12" text-anchor="middle">+ request()</text>
    <text x="150" y="145" font-family="Arial" font-size="12" text-anchor="middle">+ setState(state)</text>
    
    <!-- State -->
    <rect x="450" y="50" width="200" height="80" rx="10" ry="10" fill="#fdcdac" stroke="#333" stroke-width="2" />
    <text x="550" y="80" font-family="Arial" font-size="16" text-anchor="middle">State</text>
    <text x="550" y="105" font-family="Arial" font-size="12" text-anchor="middle">+ handle()</text>
    
    <!-- ConcreteStateA -->
    <rect x="350" y="200" width="200" height="100" rx="10" ry="10" fill="#f4cae4" stroke="#333" stroke-width="2" />
    <text x="450" y="230" font-family="Arial" font-size="16" text-anchor="middle">ConcreteStateA</text>
    <text x="450" y="255" font-family="Arial" font-size="12" text-anchor="middle">- context</text>
    <text x="450" y="275" font-family="Arial" font-size="12" text-anchor="middle">+ handle()</text>
    
    <!-- ConcreteStateB -->
    <rect x="600" y="200" width="200" height="100" rx="10" ry="10" fill="#f4cae4" stroke="#333" stroke-width="2" />
    <text x="700" y="230" font-family="Arial" font-size="16" text-anchor="middle">ConcreteStateB</text>
    <text x="700" y="255" font-family="Arial" font-size="12" text-anchor="middle">- context</text>
    <text x="700" y="275" font-family="Arial" font-size="12" text-anchor="middle">+ handle()</text>
    
    <!-- Client -->
    <rect x="50" y="200" width="120" height="80" rx="10" ry="10" fill="#e6f5c9" stroke="#333" stroke-width="2" />
    <text x="110" y="245" font-family="Arial" font-size="16" text-anchor="middle">Client</text>
    
    <!-- 関係を表す線 -->
    <line x1="250" y1="100" x2="450" y2="100" stroke="#333" stroke-width="1.5" />
    <line x1="450" y1="200" x2="550" y2="130" stroke="#333" stroke-width="1.5" />
    <line x1="700" y1="200" x2="550" y2="130" stroke="#333" stroke-width="1.5" />
    <line x1="450" y1="200" x2="150" y2="170" stroke="#333" stroke-width="1.5" stroke-dasharray="5,5" />
    <line x1="700" y1="200" x2="150" y2="170" stroke="#333" stroke-width="1.5" stroke-dasharray="5,5" />
    <line x1="170" y1="240" x2="350" y2="240" stroke="#333" stroke-width="1.5" stroke-dasharray="5,5" />
    
    <text x="350" y="25" font-family="Arial" font-size="16" text-anchor="middle" font-weight="bold">Stateパターン</text>
    
    <!-- 状態遷移の説明 -->
    <rect x="50" y="350" width="600" height="120" rx="5" ry="5" fill="#f8f9fa" stroke="#ccc" stroke-width="1" />
    <text x="350" y="370" font-family="Arial" font-size="14" text-anchor="middle" font-weight="bold">状態遷移の例</text>
    
    <rect x="100" y="390" width="120" height="60" rx="5" ry="5" fill="#f4cae4" stroke="#333" stroke-width="1" />
    <text x="160" y="425" font-family="Arial" font-size="14" text-anchor="middle">StateA</text>
    
    <rect x="300" y="390" width="120" height="60" rx="5" ry="5" fill="#f4cae4" stroke="#333" stroke-width="1" />
    <text x="360" y="425" font-family="Arial" font-size="14" text-anchor="middle">StateB</text>
    
    <rect x="500" y="390" width="120" height="60" rx="5" ry="5" fill="#f4cae4" stroke="#333" stroke-width="1" />
    <text x="560" y="425" font-family="Arial" font-size="14" text-anchor="middle">StateC</text>
    
    <line x1="220" y1="420" x2="300" y2="420" stroke="#333" stroke-width="1.5" marker-end="url(#arrowhead)" />
    <line x1="420" y1="420" x2="500" y2="420" stroke="#333" stroke-width="1.5" marker-end="url(#arrowhead)" />
    <line x1="500" y1="390" x2="220" y2="390" stroke="#333" stroke-width="1.5" marker-end="url(#arrowhead)" />
    
    <!-- マーカー定義 -->
    <defs>
        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="#333" />
        </marker>
    </defs>
  </svg>

  <h2>4. 具体例で理解する</h2>
  
  <h3>例1: 自動販売機</h3>
  <p>自動販売機の例を考えてみましょう：</p>
  <ul>
    <li><strong>Context</strong>：VendingMachine（自動販売機）- 現在の状態を保持し、動作を処理する</li>
    <li><strong>State</strong>：VendingMachineState - 各状態での振る舞いを定義するインターフェース</li>
    <li><strong>ConcreteState</strong>：
      <ul>
        <li>NoMoneyState（お金が投入されていない状態）</li>
        <li>HasMoneyState（お金が投入された状態）</li>
        <li>ProductSelectedState（商品が選択された状態）</li>
        <li>DispensingState（商品を排出中の状態）</li>
      </ul>
    </li>
  </ul>
  
  <p>この例では、自動販売機の各状態に対して別々のクラスを作成します。例えば、お金が投入されていない状態（NoMoneyState）では、「お金を入れてください」というメッセージが表示され、商品選択ボタンは無効になります。お金が投入された状態（HasMoneyState）では、商品選択ボタンが有効になり、キャンセルボタンを押すとお金が返却されます。</p>

  <p>これにより、状態ごとの振る舞いが明確に分離され、新しい状態を追加する場合でも既存のコードを変更する必要がありません。例えば、「商品切れ状態」や「メンテナンス状態」など、新しい状態を追加することが容易になります。</p>

  <h3>例2: 文書編集アプリケーション</h3>
  <p>文書編集アプリケーションの例も考えてみましょう：</p>
  <ul>
    <li><strong>Context</strong>：Document（文書）- 現在の状態を保持し、ユーザーの操作を処理する</li>
    <li><strong>State</strong>：DocumentState - 各状態での振る舞いを定義するインターフェース</li>
    <li><strong>ConcreteState</strong>：
      <ul>
        <li>ViewState（閲覧状態）- 文書を閲覧するだけの状態</li>
        <li>EditState（編集状態）- 文書を編集できる状態</li>
        <li>ReviewState（レビュー状態）- 文書のレビューを行う状態</li>
        <li>LockedState（ロック状態）- 文書がロックされている状態</li>
      </ul>
    </li>
  </ul>
  
  <p>この例では、文書の各状態に応じて、ユーザーが実行できる操作が変わります。例えば、閲覧状態では文書の内容を読むことしかできませんが、編集状態では文書の内容を変更することができます。レビュー状態ではコメントを追加することができ、ロック状態では何も変更できません。</p>

  <div style="background-color: #fff7e6; border: 1px solid #ffd591; padding: 15px; margin: 20px 0; border-radius: 5px;">
    <h3>中学生向け説明</h3>
    <p>信号機を想像してみてください。信号機には「赤」「黄」「青」という3つの状態があり、それぞれの状態で車や人がとるべき行動が変わります。赤信号なら「止まる」、青信号なら「進む」、黄信号なら「注意して止まる準備をする」というように。Stateパターンは、このように「状態」ごとに「何をするか」を別々のクラスとして分けるパターンです。例えば、ゲームのキャラクターが「歩いている状態」「走っている状態」「ジャンプしている状態」など、状態によって動作が変わる場合に便利です。これにより、ifやswitchをたくさん書く代わりに、各状態の振る舞いを明確に分けることができます。</p>
  </div>

  <h2>5. メリットとデメリット</h2>
  
  <h3>メリット</h3>
  <ul>
    <li><strong>単一責任の原則</strong>：各状態の振る舞いが独立したクラスにカプセル化される</li>
    <li><strong>開放/閉鎖の原則</strong>：新しい状態を追加しても既存のコードを変更する必要がない</li>
    <li><strong>条件分岐の排除</strong>：大きなif-elseやswitch文の代わりに多態性を利用できる</li>
    <li><strong>状態遷移の明確化</strong>：状態遷移のルールが明示的になり、理解しやすくなる</li>
    <li><strong>コードの保守性向上</strong>：各状態が分離されているため、デバッグや修正が容易</li>
  </ul>

  <h3>デメリット</h3>
  <ul>
    <li><strong>クラス数の増加</strong>：状態ごとに新しいクラスが必要になり、クラス数が増える</li>
    <li><strong>Context-State間の結合</strong>：状態クラスとコンテキストクラスの間に依存関係が生じる</li>
    <li><strong>オーバーヘッド</strong>：シンプルな状態遷移の場合は過剰設計になる可能性がある</li>
    <li><strong>状態共有の難しさ</strong>：状態間でデータを共有する場合、設計が複雑になる</li>
    <li><strong>全体把握の難しさ</strong>：状態遷移の全体像を把握するのが難しくなる場合がある</li>
  </ul>

  <h2>6. 類似パターンとの違い</h2>
  <table border="1" style="border-collapse: collapse; width: 100%;">
    <tr style="background-color: #f2f2f2;">
      <th style="padding: 10px;">パターン</th>
      <th style="padding: 10px;">主な目的</th>
      <th style="padding: 10px;">Stateとの違い</th>
    </tr>
    <tr>
      <td style="padding: 10px;"><strong>Strategy</strong></td>
      <td style="padding: 10px;">異なるアルゴリズムを交換可能にする</td>
      <td style="padding: 10px;">Strategyはクライアントが明示的に選択し、Stateはコンテキストの内部状態に基づいて自動的に変化する</td>
    </tr>
    <tr>
      <td style="padding: 10px;"><strong>Command</strong></td>
      <td style="padding: 10px;">操作をオブジェクトとしてカプセル化する</td>
      <td style="padding: 10px;">Commandは操作をカプセル化し、Stateは振る舞い全体をカプセル化する</td>
    </tr>
    <tr>
      <td style="padding: 10px;"><strong>Flyweight</strong></td>
      <td style="padding: 10px;">多数の小さなオブジェクトを効率的に扱う</td>
      <td style="padding: 10px;">Flyweightは共有オブジェクトを使用し、Stateは状態ごとに別々のオブジェクトを使用する</td>
    </tr>
    <tr>
      <td style="padding: 10px;"><strong>Memento</strong></td>
      <td style="padding: 10px;">オブジェクトの状態を保存・復元する</td>
      <td style="padding: 10px;">Mementoは過去の状態を保存し、Stateは現在の状態に基づいて振る舞いを変える</td>
    </tr>
  </table>

  <h2>7. 実践的なアドバイス</h2>
  <ol>
    <li><strong>状態遷移図を作成する</strong>：実装前に状態遷移図を作成し、状態と遷移のルールを明確にしましょう。</li>
    <li><strong>状態遷移の責任を明確にする</strong>：状態遷移の決定をContextクラスに集中させるか、各状態クラスに分散させるかを検討しましょう。</li>
    <li><strong>状態オブジェクトの共有を検討する</strong>：状態オブジェクトが状態を持たない場合は、シングルトンやフライウェイトパターンを併用して共有することを検討しましょう。</li>
    <li><strong>適切な粒度を選ぶ</strong>：すべての小さな状態変化に対して新しいクラスを作成するのではなく、意味のある状態の集合に対してクラスを作成しましょう。</li>
    <li><strong>状態履歴の管理</strong>：必要に応じて状態の履歴を管理し、前の状態に戻る機能を実装することを検討しましょう。</li>
  </ol>

  <h2>8. まとめ</h2>
  <p>Stateパターンは、オブジェクトの内部状態が変化したときに、そのオブジェクトの振る舞いを変えるデザインパターンです。各状態をクラスとして表現することで、複雑な条件分岐を避け、コードの保守性と拡張性を高めることができます。</p>

  <p>このパターンは、自動販売機、ワークフローシステム、ゲームのキャラクター制御、文書管理システムなど、状態に依存する振る舞いが多い場合に特に有効です。ただし、状態が少なく単純な場合や、状態遷移が頻繁に変更される場合は、過剰設計になる可能性があるため、適切な状況で使用することが重要です。</p>

  <div style="background-color: #f0f8ff; border: 1px solid #b0c4de; padding: 15px; margin: 20px 0; border-radius: 5px;">
    <h3>覚えておきたいポイント</h3>
    <ul>
      <li>Stateは「状態に応じて振る舞いを変える」パターン</li>
      <li>各状態をクラスとして表現し、状態ごとの振る舞いをカプセル化する</li>
      <li>複雑な条件分岐（if-elseやswitch）を排除できる</li>
      <li>新しい状態の追加が容易で、開放/閉鎖の原則に従う</li>
      <li>状態遷移のルールが明確になり、コードの保守性が向上する</li>
    </ul>
  </div>

  <h2>9. 用語集</h2>
  <dl>
    <dt><strong>コンテキスト（Context）</strong></dt>
    <dd>現在の状態を保持し、状態オブジェクトへのインターフェースを提供するオブジェクト。クライアントからのリクエストを現在の状態オブジェクトに委譲する。</dd>
    
    <dt><strong>状態（State）</strong></dt>
    <dd>特定の状態での振る舞いを定義するインターフェースまたは抽象クラス。各具体的な状態クラスが実装する。</dd>
    
    <dt><strong>具体的な状態（ConcreteState）</strong></dt>
    <dd>Stateインターフェースを実装し、特定の状態での振る舞いを提供するクラス。状態遷移のロジックを含む場合もある。</dd>
    
    <dt><strong>状態遷移（State Transition）</strong></dt>
    <dd>ある状態から別の状態への変化。特定のイベントやアクションによってトリガーされる。</dd>
    
    <dt><strong>状態遷移図（State Transition Diagram）</strong></dt>
    <dd>状態とその間の遷移を視覚的に表現した図。状態はノードとして、遷移は矢印として表される。</dd>
  </dl>
